#define get_opposite(x) __opposite_dirs[(x)]

var
	list/__opposite_dirs = list(2,1,null,8,null,null,null,4)	//used internally to assist with movement input keys

client
	var
		list/input_keys = list(0,0,0)
		list/key_events = list(null,null,null)
		list/key_listeners = newlist(/prioritylist,/prioritylist,/prioritylist)
		move_dir = 0
		analog_dir = 0
		firing = 0
	verb
		MoveKey(key as num,state as num)
			set hidden = 1
			set instant = 1
			//update the INPUT_DPAD status
			var/opposite = get_opposite(key)
			if(state)
				//if this is a keypress, turn on the key bit
				input_keys[INPUT_DPAD] |= key
				move_dir |= key
				//turn off the opposite key bit
				if(opposite & input_keys[INPUT_DPAD])
					move_dir &= ~opposite
			else
				//if this is a keyrelease, turn off the key bit
				input_keys[INPUT_DPAD] &= ~key
				move_dir &= ~key
				//turn on the opposite key bit if it's being held
				if(opposite & input_keys[INPUT_DPAD])
					move_dir |= opposite
			//generate a movekeyevent
			new/movekeyevent(src,INPUT_DPAD,key,state)

		AnalogKey(key as num,state as num)
			set hidden = 1
			set instant = 1
			var/opposite = get_opposite(key)
			if(state)
				input_keys[INPUT_ANALOG] |= key
				analog_dir |= key
				if(opposite & input_keys[INPUT_ANALOG])
					analog_dir &= ~opposite
			else
				input_keys[INPUT_ANALOG] &= ~key
				analog_dir &= ~key
				if(opposite & input_keys[INPUT_ANALOG])
					analog_dir |= opposite
			new/movekeyevent(src,INPUT_ANALOG,key,state)

		FireKey(state as num)
			set hidden = 1
			set instant = 1

			input_keys[INPUT_FIRE] = state
			if(state==1)
				if(!firing)
					firing = 1
					var/mob/actor/player/p = src.mob
					if(!p.alive)
						world.Reboot()
					else
						while(input_keys[INPUT_FIRE])
							if(p.alive)
								p.fireGun()
						firing = 0

		ReloadKey()
			set hidden = 1
			set instant = 1

			var/mob/actor/player/p = src.mob
			if(p.alive)
				p.reloadGun()

		WeaponKey(inp as num)
			set hidden = 1
			set instant = 1

			var/mob/actor/player/p = src.mob
			if(p.alive)
				p.switchWeapon(inp)
	proc
		//call these to register a keylistener to a specific hotkey
		AddKeyListener(key,datum/d,priority)
			var/prioritylist/p = key_listeners[key]
			p.Add(d,priority)

		//call these to stop listening for a specific hotkey with this object
		RemoveKeyListener(key,datum/d)
			var/prioritylist/p = key_listeners[key]
			p.Remove(d)

//keyevent objects are generated by keypresses and releases
keyevent
	var
		client/owner			//the client that this event belongs to
		keycode					//the index of the key pressed/released
		state					//whether this is a press/release
		taps = 1				//the number of sequential taps
		time					//the time this event started
		duration = 0			//how long it was held for
		current = 1				//whether the event is the most recent
		consumed = 0			//whether the event is still viable

	proc
		Consume()
			consumed = 1

	New(client/client,key,state)
		time = world.time
		owner = client
		keycode = key
		src.state = state

		var/keyevent/e = owner.key_events[key]
		owner.key_events[key] = src

		if(e)
			e.current = 0
		if(state)
			if(e && time - e.time <= TAP_DURATION)
				taps = e.taps + 1

			var/prioritylist/p = owner.key_listeners[key]

			for(var/datum/d in p.values)
				call(d,"onKeyPressed")(src)
				if(consumed)
					break
		else
			duration = time - e.time
			taps = e.taps

			var/prioritylist/p = owner.key_listeners[key]

			for(var/datum/d in p.values)
				call(d,"onKeyReleased")(src)
				if(consumed)
					break

movekeyevent
	parent_type = /keyevent
	var
		movekey

	New(client/client,key,mkey,state)
		time = world.time
		owner = client
		keycode = key
		movekey = mkey
		src.state = state

		var/movekeyevent/e = owner.key_events[key]
		owner.key_events[key] = src
		if(e)
			e.current = 0
		if(state)
			if(e)
				if(e.movekey==movekey && time - e.time <= TAP_DURATION)
					taps = e.taps + 1
				else if(e.state || time - e.time <= TAP_DURATION)
					taps = e.taps

			var/prioritylist/p = owner.key_listeners[key]
			for(var/datum/d in p.values)
				call(d,"onKeyPressed")(src)
				if(consumed)
					break
		else
			duration = time - e.time
			taps = e.taps

			var/prioritylist/p = owner.key_listeners[key]
			for(var/datum/d in p.values)
				call(d,"onKeyReleased")(src)
				if(consumed)
					break